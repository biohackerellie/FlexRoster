// api v0.0.1 4a0af99fec460d2bbe53a31541c3c387b3ea9385
// --
// Code generated by webrpc-gen@v0.19.3 with golang generator. DO NOT EDIT.
//
// webrpc-gen -schema=server.ridl -target=golang -pkg=service -server -client -out=./internal/service/proto.gen.go
package service

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)

// WebRPC description and code-gen version
func WebRPCVersion() string {
	return "v1"
}

// Schema version of your RIDL schema
func WebRPCSchemaVersion() string {
	return "v0.0.1"
}

// Schema hash generated from your RIDL schema
func WebRPCSchemaHash() string {
	return "4a0af99fec460d2bbe53a31541c3c387b3ea9385"
}

//
// Common types
//

type RequestStatus string

const (
	RequestStatus_pending  RequestStatus = "pending"
	RequestStatus_approved RequestStatus = "approved"
	RequestStatus_denied   RequestStatus = "denied"
	RequestStatus_arrived  RequestStatus = "arrived"
)

func (x RequestStatus) MarshalText() ([]byte, error) {
	return []byte(x), nil
}

func (x *RequestStatus) UnmarshalText(b []byte) error {
	*x = RequestStatus(string(b))
	return nil
}

func (x *RequestStatus) Is(values ...RequestStatus) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type Status string

const (
	Status_transferredA Status = "transferredA"
	Status_transferredN Status = "transferredN"
	Status_default      Status = "default"
)

func (x Status) MarshalText() ([]byte, error) {
	return []byte(x), nil
}

func (x *Status) UnmarshalText(b []byte) error {
	*x = Status(string(b))
	return nil
}

func (x *Status) Is(values ...Status) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

// Classroom struct
type Classroom struct {
	Id          string `json:"id"`
	RoomNumber  string `json:"roomNumber"`
	TeacherName string `json:"teacherName"`
	TeacherId   string `json:"teacherId"`
	Comment     string `json:"comment"`
	Available   bool   `json:"available"`
	IsFlex      bool   `json:"isFlex"`
}

type Availability struct {
	Date        time.Time `json:"date"`
	Id          string    `json:"id"`
	ClassroomId string    `json:"classroomId"`
	TeacherId   string    `json:"teacherId"`
	Available   bool      `json:"available"`
}

type ClassroomWithChatID struct {
	ChatId         string      `json:"chatId"`
	Classroom      *Classroom  `json:"Classroom"`
	AvailableDates []time.Time `json:"availableDates"`
}

type TodaysAvailability struct {
	Id        string `json:"id"`
	Available bool   `json:"available"`
}

type ClassroomWithAvailable struct {
	Classroom      *Classroom  `json:"Classroom"`
	AvailableDates []time.Time `json:"availableDates"`
}

type ClassroomWithCount struct {
	Classroom *Classroom `json:"Classroom"`
	Count     int64      `json:"count"`
}

type Request struct {
	Id                 int32         `json:"ID"`
	StudentID          string        `json:"StudentID"`
	StudentName        string        `json:"StudentName"`
	NewTeacher         string        `json:"NewTeacher"`
	NewTeacherName     string        `json:"NewTeacherName"`
	CurrentTeacher     string        `json:"CurrentTeacher"`
	CurrentTeacherName string        `json:"CurrentTeacherName"`
	DateRequested      time.Time     `json:"DateRequested"`
	Status             RequestStatus `json:"Status"`
	Arrived            bool          `json:"Arrived"`
	Timestamp          string        `json:"Timestamp"`
}

type Student struct {
	StudentEmail string `json:"StudentEmail"`
	StudentName  string `json:"StudentName"`
	ClassroomId  string `json:"ClassroomId"`
	Status       Status `json:"Status"`
	Id           int32  `json:"ID"`
}

type AllStudentMap struct {
	StudentEmail string `json:"StudentEmail"`
	StudentName  string `json:"StudentName"`
	Status       Status `json:"Status"`
	TeacherName  string `json:"TeacherName"`
	RosterId     int32  `json:"RosterId"`
}

type StudentWithClassroom struct {
	Student   *Student   `json:"student"`
	Classroom *Classroom `json:"classroom"`
	Available bool       `json:"Available"`
}

type User struct {
	Id            string    `json:"ID"`
	Name          string    `json:"Name"`
	Email         string    `json:"Email"`
	EmailVerified time.Time `json:"EmailVerified"`
	Image         string    `json:"Image"`
	Role          string    `json:"Role"`
}

type Teacher struct {
	User      *User      `json:"user"`
	Classroom *Classroom `json:"classroom"`
}

type TeacherWithRoster struct {
	User      *User      `json:"user"`
	Student   *Student   `json:"student"`
	Classroom *Classroom `json:"classroom"`
}

type StudentWithUser struct {
	StudentEmail string `json:"StudentEmail"`
	StudentName  string `json:"StudentName"`
	Status       Status `json:"Status"`
	StudentId    string `json:"StudentId"`
	RoomNumber   string `json:"RoomNumber"`
	TeacherName  string `json:"TeacherName"`
	ClassroomId  string `json:"ClassroomId"`
	Comment      string `json:"Comment"`
	TeacherId    string `json:"TeacherId"`
}

type StudentRequests struct {
	Student   *Student   `json:"student"`
	Requests  []*Request `json:"requests"`
	Classroom *Classroom `json:"classroom"`
}

type TeacherRequests struct {
	IncomingRequests []*Request `json:"IncomingRequests"`
	OutgoingRequests []*Request `json:"OutgoingRequests"`
}

type StudentDetails struct {
	Student  *StudentWithUser `json:"Student"`
	Requests []*Request       `json:"Requests"`
}

var WebRPCServices = map[string][]string{
	"ClassroomService": {
		"GetClasses",
		"GetSpecificClassroom",
		"NewComment",
		"DeleteComment",
		"SetAvailability",
		"RoomsWithCount",
		"GetAvailability",
		"DeleteAvailability",
	},
	"RequestService": {
		"GetRequests",
		"GetAllRequests",
		"NewRequest",
		"UpdateRequest",
		"GetTeacherRequests",
	},
	"StudentService": {
		"AllStudentsMap",
		"RosterByClassroomId",
		"RosterById",
		"RosterByTeacherId",
		"GetAllStudents",
		"UpdateStudentStatus",
	},
	"UserService": {
		"GetTeacher",
		"GetUser",
		"GetTeacherWithRoster",
		"GetStudent",
		"GetStudentDetails",
	},
}

//
// Server types
//

type ClassroomService interface {
	GetClasses(ctx context.Context, id string) ([]*ClassroomWithChatID, error)
	GetSpecificClassroom(ctx context.Context, id string) (*Classroom, error)
	NewComment(ctx context.Context, id string, comment string) error
	DeleteComment(ctx context.Context, id string) error
	SetAvailability(ctx context.Context, teacherId string, classroomId string, dates []time.Time) error
	RoomsWithCount(ctx context.Context) ([]*ClassroomWithCount, error)
	GetAvailability(ctx context.Context, id string) ([]*Availability, error)
	DeleteAvailability(ctx context.Context, id string, date time.Time) error
}

type RequestService interface {
	GetRequests(ctx context.Context, userId string) ([]*Request, error)
	GetAllRequests(ctx context.Context) ([]*Request, error)
	NewRequest(ctx context.Context, studentName string, teacherRequest bool, studentID string, requestStatus RequestStatus, dateRequested time.Time, newTeacher string, newTeacherName string, currentTeacher string, currentTeacherName string) error
	UpdateRequest(ctx context.Context, id int32, status RequestStatus) error
	GetTeacherRequests(ctx context.Context, teacherId string) (*TeacherRequests, error)
}

type StudentService interface {
	AllStudentsMap(ctx context.Context) ([]*AllStudentMap, error)
	RosterByClassroomId(ctx context.Context, classroomId string) ([]*StudentWithClassroom, error)
	RosterById(ctx context.Context, id int32) ([]*Student, error)
	RosterByTeacherId(ctx context.Context, teacherId string) ([]*StudentWithUser, error)
	GetAllStudents(ctx context.Context) ([]*Student, error)
	UpdateStudentStatus(ctx context.Context, status Status, studentEmail string) error
}

type UserService interface {
	GetTeacher(ctx context.Context, id string) (*Teacher, error)
	GetUser(ctx context.Context, id string) (*User, error)
	GetTeacherWithRoster(ctx context.Context, id string) (*TeacherWithRoster, error)
	GetStudent(ctx context.Context, id string) (*StudentWithUser, error)
	GetStudentDetails(ctx context.Context, id string) (*StudentDetails, error)
}

//
// Client types
//

type ClassroomServiceClient interface {
	GetClasses(ctx context.Context, id string) ([]*ClassroomWithChatID, error)
	GetSpecificClassroom(ctx context.Context, id string) (*Classroom, error)
	NewComment(ctx context.Context, id string, comment string) error
	DeleteComment(ctx context.Context, id string) error
	SetAvailability(ctx context.Context, teacherId string, classroomId string, dates []time.Time) error
	RoomsWithCount(ctx context.Context) ([]*ClassroomWithCount, error)
	GetAvailability(ctx context.Context, id string) ([]*Availability, error)
	DeleteAvailability(ctx context.Context, id string, date time.Time) error
}

type RequestServiceClient interface {
	GetRequests(ctx context.Context, userId string) ([]*Request, error)
	GetAllRequests(ctx context.Context) ([]*Request, error)
	NewRequest(ctx context.Context, studentName string, teacherRequest bool, studentID string, requestStatus RequestStatus, dateRequested time.Time, newTeacher string, newTeacherName string, currentTeacher string, currentTeacherName string) error
	UpdateRequest(ctx context.Context, id int32, status RequestStatus) error
	GetTeacherRequests(ctx context.Context, teacherId string) (*TeacherRequests, error)
}

type StudentServiceClient interface {
	AllStudentsMap(ctx context.Context) ([]*AllStudentMap, error)
	RosterByClassroomId(ctx context.Context, classroomId string) ([]*StudentWithClassroom, error)
	RosterById(ctx context.Context, id int32) ([]*Student, error)
	RosterByTeacherId(ctx context.Context, teacherId string) ([]*StudentWithUser, error)
	GetAllStudents(ctx context.Context) ([]*Student, error)
	UpdateStudentStatus(ctx context.Context, status Status, studentEmail string) error
}

type UserServiceClient interface {
	GetTeacher(ctx context.Context, id string) (*Teacher, error)
	GetUser(ctx context.Context, id string) (*User, error)
	GetTeacherWithRoster(ctx context.Context, id string) (*TeacherWithRoster, error)
	GetStudent(ctx context.Context, id string) (*StudentWithUser, error)
	GetStudentDetails(ctx context.Context, id string) (*StudentDetails, error)
}

//
// Server
//

type WebRPCServer interface {
	http.Handler
}

type classroomServiceServer struct {
	ClassroomService
	OnError func(r *http.Request, rpcErr *WebRPCError)
}

func NewClassroomServiceServer(svc ClassroomService) *classroomServiceServer {
	return &classroomServiceServer{
		ClassroomService: svc,
	}
}

func (s *classroomServiceServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	defer func() {
		// In case of a panic, serve a HTTP 500 error and then panic.
		if rr := recover(); rr != nil {
			s.sendErrorJSON(w, r, ErrWebrpcServerPanic.WithCause(fmt.Errorf("%v", rr)))
			panic(rr)
		}
	}()

	ctx := r.Context()
	ctx = context.WithValue(ctx, HTTPResponseWriterCtxKey, w)
	ctx = context.WithValue(ctx, HTTPRequestCtxKey, r)
	ctx = context.WithValue(ctx, ServiceNameCtxKey, "ClassroomService")

	var handler func(ctx context.Context, w http.ResponseWriter, r *http.Request)
	switch r.URL.Path {
	case "/rpc/ClassroomService/GetClasses":
		handler = s.serveGetClassesJSON
	case "/rpc/ClassroomService/GetSpecificClassroom":
		handler = s.serveGetSpecificClassroomJSON
	case "/rpc/ClassroomService/NewComment":
		handler = s.serveNewCommentJSON
	case "/rpc/ClassroomService/DeleteComment":
		handler = s.serveDeleteCommentJSON
	case "/rpc/ClassroomService/SetAvailability":
		handler = s.serveSetAvailabilityJSON
	case "/rpc/ClassroomService/RoomsWithCount":
		handler = s.serveRoomsWithCountJSON
	case "/rpc/ClassroomService/GetAvailability":
		handler = s.serveGetAvailabilityJSON
	case "/rpc/ClassroomService/DeleteAvailability":
		handler = s.serveDeleteAvailabilityJSON
	default:
		err := ErrWebrpcBadRoute.WithCause(fmt.Errorf("no handler for path %q", r.URL.Path))
		s.sendErrorJSON(w, r, err)
		return
	}

	if r.Method != "POST" {
		w.Header().Add("Allow", "POST") // RFC 9110.
		err := ErrWebrpcBadMethod.WithCause(fmt.Errorf("unsupported method %q (only POST is allowed)", r.Method))
		s.sendErrorJSON(w, r, err)
		return
	}

	contentType := r.Header.Get("Content-Type")
	if i := strings.Index(contentType, ";"); i >= 0 {
		contentType = contentType[:i]
	}
	contentType = strings.TrimSpace(strings.ToLower(contentType))

	switch contentType {
	case "application/json":
		handler(ctx, w, r)
	default:
		err := ErrWebrpcBadRequest.WithCause(fmt.Errorf("unexpected Content-Type: %q", r.Header.Get("Content-Type")))
		s.sendErrorJSON(w, r, err)
	}
}

func (s *classroomServiceServer) serveGetClassesJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "GetClasses")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 string `json:"id"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	ret0, err := s.ClassroomService.GetClasses(ctx, reqPayload.Arg0)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	respPayload := struct {
		Ret0 []*ClassroomWithChatID `json:"classrooms"`
	}{ret0}
	respBody, err := json.Marshal(respPayload)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to marshal json response: %w", err)))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *classroomServiceServer) serveGetSpecificClassroomJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "GetSpecificClassroom")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 string `json:"id"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	ret0, err := s.ClassroomService.GetSpecificClassroom(ctx, reqPayload.Arg0)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	respPayload := struct {
		Ret0 *Classroom `json:"classroom"`
	}{ret0}
	respBody, err := json.Marshal(respPayload)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to marshal json response: %w", err)))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *classroomServiceServer) serveNewCommentJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "NewComment")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 string `json:"id"`
		Arg1 string `json:"comment"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	err = s.ClassroomService.NewComment(ctx, reqPayload.Arg0, reqPayload.Arg1)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write([]byte("{}"))
}

func (s *classroomServiceServer) serveDeleteCommentJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "DeleteComment")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 string `json:"id"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	err = s.ClassroomService.DeleteComment(ctx, reqPayload.Arg0)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write([]byte("{}"))
}

func (s *classroomServiceServer) serveSetAvailabilityJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "SetAvailability")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 string      `json:"teacherId"`
		Arg1 string      `json:"classroomId"`
		Arg2 []time.Time `json:"dates"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	err = s.ClassroomService.SetAvailability(ctx, reqPayload.Arg0, reqPayload.Arg1, reqPayload.Arg2)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write([]byte("{}"))
}

func (s *classroomServiceServer) serveRoomsWithCountJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "RoomsWithCount")

	// Call service method implementation.
	ret0, err := s.ClassroomService.RoomsWithCount(ctx)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	respPayload := struct {
		Ret0 []*ClassroomWithCount `json:"classrooms"`
	}{ret0}
	respBody, err := json.Marshal(respPayload)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to marshal json response: %w", err)))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *classroomServiceServer) serveGetAvailabilityJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "GetAvailability")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 string `json:"id"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	ret0, err := s.ClassroomService.GetAvailability(ctx, reqPayload.Arg0)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	respPayload := struct {
		Ret0 []*Availability `json:"availability"`
	}{ret0}
	respBody, err := json.Marshal(respPayload)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to marshal json response: %w", err)))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *classroomServiceServer) serveDeleteAvailabilityJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "DeleteAvailability")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 string    `json:"id"`
		Arg1 time.Time `json:"date"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	err = s.ClassroomService.DeleteAvailability(ctx, reqPayload.Arg0, reqPayload.Arg1)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write([]byte("{}"))
}

func (s *classroomServiceServer) sendErrorJSON(w http.ResponseWriter, r *http.Request, rpcErr WebRPCError) {
	if s.OnError != nil {
		s.OnError(r, &rpcErr)
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(rpcErr.HTTPStatus)

	respBody, _ := json.Marshal(rpcErr)
	w.Write(respBody)
}

type requestServiceServer struct {
	RequestService
	OnError func(r *http.Request, rpcErr *WebRPCError)
}

func NewRequestServiceServer(svc RequestService) *requestServiceServer {
	return &requestServiceServer{
		RequestService: svc,
	}
}

func (s *requestServiceServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	defer func() {
		// In case of a panic, serve a HTTP 500 error and then panic.
		if rr := recover(); rr != nil {
			s.sendErrorJSON(w, r, ErrWebrpcServerPanic.WithCause(fmt.Errorf("%v", rr)))
			panic(rr)
		}
	}()

	ctx := r.Context()
	ctx = context.WithValue(ctx, HTTPResponseWriterCtxKey, w)
	ctx = context.WithValue(ctx, HTTPRequestCtxKey, r)
	ctx = context.WithValue(ctx, ServiceNameCtxKey, "RequestService")

	var handler func(ctx context.Context, w http.ResponseWriter, r *http.Request)
	switch r.URL.Path {
	case "/rpc/RequestService/GetRequests":
		handler = s.serveGetRequestsJSON
	case "/rpc/RequestService/GetAllRequests":
		handler = s.serveGetAllRequestsJSON
	case "/rpc/RequestService/NewRequest":
		handler = s.serveNewRequestJSON
	case "/rpc/RequestService/UpdateRequest":
		handler = s.serveUpdateRequestJSON
	case "/rpc/RequestService/GetTeacherRequests":
		handler = s.serveGetTeacherRequestsJSON
	default:
		err := ErrWebrpcBadRoute.WithCause(fmt.Errorf("no handler for path %q", r.URL.Path))
		s.sendErrorJSON(w, r, err)
		return
	}

	if r.Method != "POST" {
		w.Header().Add("Allow", "POST") // RFC 9110.
		err := ErrWebrpcBadMethod.WithCause(fmt.Errorf("unsupported method %q (only POST is allowed)", r.Method))
		s.sendErrorJSON(w, r, err)
		return
	}

	contentType := r.Header.Get("Content-Type")
	if i := strings.Index(contentType, ";"); i >= 0 {
		contentType = contentType[:i]
	}
	contentType = strings.TrimSpace(strings.ToLower(contentType))

	switch contentType {
	case "application/json":
		handler(ctx, w, r)
	default:
		err := ErrWebrpcBadRequest.WithCause(fmt.Errorf("unexpected Content-Type: %q", r.Header.Get("Content-Type")))
		s.sendErrorJSON(w, r, err)
	}
}

func (s *requestServiceServer) serveGetRequestsJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "GetRequests")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 string `json:"userId"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	ret0, err := s.RequestService.GetRequests(ctx, reqPayload.Arg0)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	respPayload := struct {
		Ret0 []*Request `json:"requests"`
	}{ret0}
	respBody, err := json.Marshal(respPayload)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to marshal json response: %w", err)))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *requestServiceServer) serveGetAllRequestsJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "GetAllRequests")

	// Call service method implementation.
	ret0, err := s.RequestService.GetAllRequests(ctx)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	respPayload := struct {
		Ret0 []*Request `json:"requests"`
	}{ret0}
	respBody, err := json.Marshal(respPayload)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to marshal json response: %w", err)))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *requestServiceServer) serveNewRequestJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "NewRequest")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 string        `json:"studentName"`
		Arg1 bool          `json:"teacherRequest"`
		Arg2 string        `json:"studentID"`
		Arg3 RequestStatus `json:"requestStatus"`
		Arg4 time.Time     `json:"dateRequested"`
		Arg5 string        `json:"newTeacher"`
		Arg6 string        `json:"newTeacherName"`
		Arg7 string        `json:"currentTeacher"`
		Arg8 string        `json:"currentTeacherName"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	err = s.RequestService.NewRequest(ctx, reqPayload.Arg0, reqPayload.Arg1, reqPayload.Arg2, reqPayload.Arg3, reqPayload.Arg4, reqPayload.Arg5, reqPayload.Arg6, reqPayload.Arg7, reqPayload.Arg8)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write([]byte("{}"))
}

func (s *requestServiceServer) serveUpdateRequestJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "UpdateRequest")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 int32         `json:"id"`
		Arg1 RequestStatus `json:"status"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	err = s.RequestService.UpdateRequest(ctx, reqPayload.Arg0, reqPayload.Arg1)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write([]byte("{}"))
}

func (s *requestServiceServer) serveGetTeacherRequestsJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "GetTeacherRequests")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 string `json:"teacherId"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	ret0, err := s.RequestService.GetTeacherRequests(ctx, reqPayload.Arg0)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	respPayload := struct {
		Ret0 *TeacherRequests `json:"requests"`
	}{ret0}
	respBody, err := json.Marshal(respPayload)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to marshal json response: %w", err)))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *requestServiceServer) sendErrorJSON(w http.ResponseWriter, r *http.Request, rpcErr WebRPCError) {
	if s.OnError != nil {
		s.OnError(r, &rpcErr)
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(rpcErr.HTTPStatus)

	respBody, _ := json.Marshal(rpcErr)
	w.Write(respBody)
}

type studentServiceServer struct {
	StudentService
	OnError func(r *http.Request, rpcErr *WebRPCError)
}

func NewStudentServiceServer(svc StudentService) *studentServiceServer {
	return &studentServiceServer{
		StudentService: svc,
	}
}

func (s *studentServiceServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	defer func() {
		// In case of a panic, serve a HTTP 500 error and then panic.
		if rr := recover(); rr != nil {
			s.sendErrorJSON(w, r, ErrWebrpcServerPanic.WithCause(fmt.Errorf("%v", rr)))
			panic(rr)
		}
	}()

	ctx := r.Context()
	ctx = context.WithValue(ctx, HTTPResponseWriterCtxKey, w)
	ctx = context.WithValue(ctx, HTTPRequestCtxKey, r)
	ctx = context.WithValue(ctx, ServiceNameCtxKey, "StudentService")

	var handler func(ctx context.Context, w http.ResponseWriter, r *http.Request)
	switch r.URL.Path {
	case "/rpc/StudentService/AllStudentsMap":
		handler = s.serveAllStudentsMapJSON
	case "/rpc/StudentService/RosterByClassroomId":
		handler = s.serveRosterByClassroomIdJSON
	case "/rpc/StudentService/RosterById":
		handler = s.serveRosterByIdJSON
	case "/rpc/StudentService/RosterByTeacherId":
		handler = s.serveRosterByTeacherIdJSON
	case "/rpc/StudentService/GetAllStudents":
		handler = s.serveGetAllStudentsJSON
	case "/rpc/StudentService/UpdateStudentStatus":
		handler = s.serveUpdateStudentStatusJSON
	default:
		err := ErrWebrpcBadRoute.WithCause(fmt.Errorf("no handler for path %q", r.URL.Path))
		s.sendErrorJSON(w, r, err)
		return
	}

	if r.Method != "POST" {
		w.Header().Add("Allow", "POST") // RFC 9110.
		err := ErrWebrpcBadMethod.WithCause(fmt.Errorf("unsupported method %q (only POST is allowed)", r.Method))
		s.sendErrorJSON(w, r, err)
		return
	}

	contentType := r.Header.Get("Content-Type")
	if i := strings.Index(contentType, ";"); i >= 0 {
		contentType = contentType[:i]
	}
	contentType = strings.TrimSpace(strings.ToLower(contentType))

	switch contentType {
	case "application/json":
		handler(ctx, w, r)
	default:
		err := ErrWebrpcBadRequest.WithCause(fmt.Errorf("unexpected Content-Type: %q", r.Header.Get("Content-Type")))
		s.sendErrorJSON(w, r, err)
	}
}

func (s *studentServiceServer) serveAllStudentsMapJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "AllStudentsMap")

	// Call service method implementation.
	ret0, err := s.StudentService.AllStudentsMap(ctx)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	respPayload := struct {
		Ret0 []*AllStudentMap `json:"students"`
	}{ret0}
	respBody, err := json.Marshal(respPayload)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to marshal json response: %w", err)))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *studentServiceServer) serveRosterByClassroomIdJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "RosterByClassroomId")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 string `json:"classroomId"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	ret0, err := s.StudentService.RosterByClassroomId(ctx, reqPayload.Arg0)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	respPayload := struct {
		Ret0 []*StudentWithClassroom `json:"students"`
	}{ret0}
	respBody, err := json.Marshal(respPayload)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to marshal json response: %w", err)))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *studentServiceServer) serveRosterByIdJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "RosterById")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 int32 `json:"id"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	ret0, err := s.StudentService.RosterById(ctx, reqPayload.Arg0)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	respPayload := struct {
		Ret0 []*Student `json:"students"`
	}{ret0}
	respBody, err := json.Marshal(respPayload)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to marshal json response: %w", err)))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *studentServiceServer) serveRosterByTeacherIdJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "RosterByTeacherId")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 string `json:"teacherId"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	ret0, err := s.StudentService.RosterByTeacherId(ctx, reqPayload.Arg0)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	respPayload := struct {
		Ret0 []*StudentWithUser `json:"students"`
	}{ret0}
	respBody, err := json.Marshal(respPayload)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to marshal json response: %w", err)))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *studentServiceServer) serveGetAllStudentsJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "GetAllStudents")

	// Call service method implementation.
	ret0, err := s.StudentService.GetAllStudents(ctx)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	respPayload := struct {
		Ret0 []*Student `json:"students"`
	}{ret0}
	respBody, err := json.Marshal(respPayload)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to marshal json response: %w", err)))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *studentServiceServer) serveUpdateStudentStatusJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "UpdateStudentStatus")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 Status `json:"status"`
		Arg1 string `json:"studentEmail"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	err = s.StudentService.UpdateStudentStatus(ctx, reqPayload.Arg0, reqPayload.Arg1)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write([]byte("{}"))
}

func (s *studentServiceServer) sendErrorJSON(w http.ResponseWriter, r *http.Request, rpcErr WebRPCError) {
	if s.OnError != nil {
		s.OnError(r, &rpcErr)
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(rpcErr.HTTPStatus)

	respBody, _ := json.Marshal(rpcErr)
	w.Write(respBody)
}

type userServiceServer struct {
	UserService
	OnError func(r *http.Request, rpcErr *WebRPCError)
}

func NewUserServiceServer(svc UserService) *userServiceServer {
	return &userServiceServer{
		UserService: svc,
	}
}

func (s *userServiceServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	defer func() {
		// In case of a panic, serve a HTTP 500 error and then panic.
		if rr := recover(); rr != nil {
			s.sendErrorJSON(w, r, ErrWebrpcServerPanic.WithCause(fmt.Errorf("%v", rr)))
			panic(rr)
		}
	}()

	ctx := r.Context()
	ctx = context.WithValue(ctx, HTTPResponseWriterCtxKey, w)
	ctx = context.WithValue(ctx, HTTPRequestCtxKey, r)
	ctx = context.WithValue(ctx, ServiceNameCtxKey, "UserService")

	var handler func(ctx context.Context, w http.ResponseWriter, r *http.Request)
	switch r.URL.Path {
	case "/rpc/UserService/GetTeacher":
		handler = s.serveGetTeacherJSON
	case "/rpc/UserService/GetUser":
		handler = s.serveGetUserJSON
	case "/rpc/UserService/GetTeacherWithRoster":
		handler = s.serveGetTeacherWithRosterJSON
	case "/rpc/UserService/GetStudent":
		handler = s.serveGetStudentJSON
	case "/rpc/UserService/GetStudentDetails":
		handler = s.serveGetStudentDetailsJSON
	default:
		err := ErrWebrpcBadRoute.WithCause(fmt.Errorf("no handler for path %q", r.URL.Path))
		s.sendErrorJSON(w, r, err)
		return
	}

	if r.Method != "POST" {
		w.Header().Add("Allow", "POST") // RFC 9110.
		err := ErrWebrpcBadMethod.WithCause(fmt.Errorf("unsupported method %q (only POST is allowed)", r.Method))
		s.sendErrorJSON(w, r, err)
		return
	}

	contentType := r.Header.Get("Content-Type")
	if i := strings.Index(contentType, ";"); i >= 0 {
		contentType = contentType[:i]
	}
	contentType = strings.TrimSpace(strings.ToLower(contentType))

	switch contentType {
	case "application/json":
		handler(ctx, w, r)
	default:
		err := ErrWebrpcBadRequest.WithCause(fmt.Errorf("unexpected Content-Type: %q", r.Header.Get("Content-Type")))
		s.sendErrorJSON(w, r, err)
	}
}

func (s *userServiceServer) serveGetTeacherJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "GetTeacher")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 string `json:"id"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	ret0, err := s.UserService.GetTeacher(ctx, reqPayload.Arg0)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	respPayload := struct {
		Ret0 *Teacher `json:"teacher"`
	}{ret0}
	respBody, err := json.Marshal(respPayload)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to marshal json response: %w", err)))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *userServiceServer) serveGetUserJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "GetUser")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 string `json:"id"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	ret0, err := s.UserService.GetUser(ctx, reqPayload.Arg0)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	respPayload := struct {
		Ret0 *User `json:"user"`
	}{ret0}
	respBody, err := json.Marshal(respPayload)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to marshal json response: %w", err)))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *userServiceServer) serveGetTeacherWithRosterJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "GetTeacherWithRoster")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 string `json:"id"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	ret0, err := s.UserService.GetTeacherWithRoster(ctx, reqPayload.Arg0)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	respPayload := struct {
		Ret0 *TeacherWithRoster `json:"teacherWithRoster"`
	}{ret0}
	respBody, err := json.Marshal(respPayload)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to marshal json response: %w", err)))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *userServiceServer) serveGetStudentJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "GetStudent")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 string `json:"id"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	ret0, err := s.UserService.GetStudent(ctx, reqPayload.Arg0)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	respPayload := struct {
		Ret0 *StudentWithUser `json:"student"`
	}{ret0}
	respBody, err := json.Marshal(respPayload)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to marshal json response: %w", err)))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *userServiceServer) serveGetStudentDetailsJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "GetStudentDetails")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 string `json:"id"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	ret0, err := s.UserService.GetStudentDetails(ctx, reqPayload.Arg0)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	respPayload := struct {
		Ret0 *StudentDetails `json:"details"`
	}{ret0}
	respBody, err := json.Marshal(respPayload)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to marshal json response: %w", err)))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *userServiceServer) sendErrorJSON(w http.ResponseWriter, r *http.Request, rpcErr WebRPCError) {
	if s.OnError != nil {
		s.OnError(r, &rpcErr)
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(rpcErr.HTTPStatus)

	respBody, _ := json.Marshal(rpcErr)
	w.Write(respBody)
}

func RespondWithError(w http.ResponseWriter, err error) {
	rpcErr, ok := err.(WebRPCError)
	if !ok {
		rpcErr = ErrWebrpcEndpoint.WithCause(err)
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(rpcErr.HTTPStatus)

	respBody, _ := json.Marshal(rpcErr)
	w.Write(respBody)
}

//
// Client
//

const ClassroomServicePathPrefix = "/rpc/ClassroomService/"
const RequestServicePathPrefix = "/rpc/RequestService/"
const StudentServicePathPrefix = "/rpc/StudentService/"
const UserServicePathPrefix = "/rpc/UserService/"

type classroomServiceClient struct {
	client HTTPClient
	urls   [8]string
}

func NewClassroomServiceClient(addr string, client HTTPClient) ClassroomServiceClient {
	prefix := urlBase(addr) + ClassroomServicePathPrefix
	urls := [8]string{
		prefix + "GetClasses",
		prefix + "GetSpecificClassroom",
		prefix + "NewComment",
		prefix + "DeleteComment",
		prefix + "SetAvailability",
		prefix + "RoomsWithCount",
		prefix + "GetAvailability",
		prefix + "DeleteAvailability",
	}
	return &classroomServiceClient{
		client: client,
		urls:   urls,
	}
}

func (c *classroomServiceClient) GetClasses(ctx context.Context, id string) ([]*ClassroomWithChatID, error) {
	in := struct {
		Arg0 string `json:"id"`
	}{id}
	out := struct {
		Ret0 []*ClassroomWithChatID `json:"classrooms"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[0], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *classroomServiceClient) GetSpecificClassroom(ctx context.Context, id string) (*Classroom, error) {
	in := struct {
		Arg0 string `json:"id"`
	}{id}
	out := struct {
		Ret0 *Classroom `json:"classroom"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[1], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *classroomServiceClient) NewComment(ctx context.Context, id string, comment string) error {
	in := struct {
		Arg0 string `json:"id"`
		Arg1 string `json:"comment"`
	}{id, comment}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[2], in, nil)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return err
}

func (c *classroomServiceClient) DeleteComment(ctx context.Context, id string) error {
	in := struct {
		Arg0 string `json:"id"`
	}{id}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[3], in, nil)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return err
}

func (c *classroomServiceClient) SetAvailability(ctx context.Context, teacherId string, classroomId string, dates []time.Time) error {
	in := struct {
		Arg0 string      `json:"teacherId"`
		Arg1 string      `json:"classroomId"`
		Arg2 []time.Time `json:"dates"`
	}{teacherId, classroomId, dates}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[4], in, nil)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return err
}

func (c *classroomServiceClient) RoomsWithCount(ctx context.Context) ([]*ClassroomWithCount, error) {
	out := struct {
		Ret0 []*ClassroomWithCount `json:"classrooms"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[5], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *classroomServiceClient) GetAvailability(ctx context.Context, id string) ([]*Availability, error) {
	in := struct {
		Arg0 string `json:"id"`
	}{id}
	out := struct {
		Ret0 []*Availability `json:"availability"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[6], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *classroomServiceClient) DeleteAvailability(ctx context.Context, id string, date time.Time) error {
	in := struct {
		Arg0 string    `json:"id"`
		Arg1 time.Time `json:"date"`
	}{id, date}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[7], in, nil)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return err
}

type requestServiceClient struct {
	client HTTPClient
	urls   [5]string
}

func NewRequestServiceClient(addr string, client HTTPClient) RequestServiceClient {
	prefix := urlBase(addr) + RequestServicePathPrefix
	urls := [5]string{
		prefix + "GetRequests",
		prefix + "GetAllRequests",
		prefix + "NewRequest",
		prefix + "UpdateRequest",
		prefix + "GetTeacherRequests",
	}
	return &requestServiceClient{
		client: client,
		urls:   urls,
	}
}

func (c *requestServiceClient) GetRequests(ctx context.Context, userId string) ([]*Request, error) {
	in := struct {
		Arg0 string `json:"userId"`
	}{userId}
	out := struct {
		Ret0 []*Request `json:"requests"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[0], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *requestServiceClient) GetAllRequests(ctx context.Context) ([]*Request, error) {
	out := struct {
		Ret0 []*Request `json:"requests"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[1], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *requestServiceClient) NewRequest(ctx context.Context, studentName string, teacherRequest bool, studentID string, requestStatus RequestStatus, dateRequested time.Time, newTeacher string, newTeacherName string, currentTeacher string, currentTeacherName string) error {
	in := struct {
		Arg0 string        `json:"studentName"`
		Arg1 bool          `json:"teacherRequest"`
		Arg2 string        `json:"studentID"`
		Arg3 RequestStatus `json:"requestStatus"`
		Arg4 time.Time     `json:"dateRequested"`
		Arg5 string        `json:"newTeacher"`
		Arg6 string        `json:"newTeacherName"`
		Arg7 string        `json:"currentTeacher"`
		Arg8 string        `json:"currentTeacherName"`
	}{studentName, teacherRequest, studentID, requestStatus, dateRequested, newTeacher, newTeacherName, currentTeacher, currentTeacherName}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[2], in, nil)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return err
}

func (c *requestServiceClient) UpdateRequest(ctx context.Context, id int32, status RequestStatus) error {
	in := struct {
		Arg0 int32         `json:"id"`
		Arg1 RequestStatus `json:"status"`
	}{id, status}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[3], in, nil)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return err
}

func (c *requestServiceClient) GetTeacherRequests(ctx context.Context, teacherId string) (*TeacherRequests, error) {
	in := struct {
		Arg0 string `json:"teacherId"`
	}{teacherId}
	out := struct {
		Ret0 *TeacherRequests `json:"requests"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[4], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

type studentServiceClient struct {
	client HTTPClient
	urls   [6]string
}

func NewStudentServiceClient(addr string, client HTTPClient) StudentServiceClient {
	prefix := urlBase(addr) + StudentServicePathPrefix
	urls := [6]string{
		prefix + "AllStudentsMap",
		prefix + "RosterByClassroomId",
		prefix + "RosterById",
		prefix + "RosterByTeacherId",
		prefix + "GetAllStudents",
		prefix + "UpdateStudentStatus",
	}
	return &studentServiceClient{
		client: client,
		urls:   urls,
	}
}

func (c *studentServiceClient) AllStudentsMap(ctx context.Context) ([]*AllStudentMap, error) {
	out := struct {
		Ret0 []*AllStudentMap `json:"students"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[0], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *studentServiceClient) RosterByClassroomId(ctx context.Context, classroomId string) ([]*StudentWithClassroom, error) {
	in := struct {
		Arg0 string `json:"classroomId"`
	}{classroomId}
	out := struct {
		Ret0 []*StudentWithClassroom `json:"students"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[1], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *studentServiceClient) RosterById(ctx context.Context, id int32) ([]*Student, error) {
	in := struct {
		Arg0 int32 `json:"id"`
	}{id}
	out := struct {
		Ret0 []*Student `json:"students"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[2], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *studentServiceClient) RosterByTeacherId(ctx context.Context, teacherId string) ([]*StudentWithUser, error) {
	in := struct {
		Arg0 string `json:"teacherId"`
	}{teacherId}
	out := struct {
		Ret0 []*StudentWithUser `json:"students"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[3], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *studentServiceClient) GetAllStudents(ctx context.Context) ([]*Student, error) {
	out := struct {
		Ret0 []*Student `json:"students"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[4], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *studentServiceClient) UpdateStudentStatus(ctx context.Context, status Status, studentEmail string) error {
	in := struct {
		Arg0 Status `json:"status"`
		Arg1 string `json:"studentEmail"`
	}{status, studentEmail}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[5], in, nil)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return err
}

type userServiceClient struct {
	client HTTPClient
	urls   [5]string
}

func NewUserServiceClient(addr string, client HTTPClient) UserServiceClient {
	prefix := urlBase(addr) + UserServicePathPrefix
	urls := [5]string{
		prefix + "GetTeacher",
		prefix + "GetUser",
		prefix + "GetTeacherWithRoster",
		prefix + "GetStudent",
		prefix + "GetStudentDetails",
	}
	return &userServiceClient{
		client: client,
		urls:   urls,
	}
}

func (c *userServiceClient) GetTeacher(ctx context.Context, id string) (*Teacher, error) {
	in := struct {
		Arg0 string `json:"id"`
	}{id}
	out := struct {
		Ret0 *Teacher `json:"teacher"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[0], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *userServiceClient) GetUser(ctx context.Context, id string) (*User, error) {
	in := struct {
		Arg0 string `json:"id"`
	}{id}
	out := struct {
		Ret0 *User `json:"user"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[1], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *userServiceClient) GetTeacherWithRoster(ctx context.Context, id string) (*TeacherWithRoster, error) {
	in := struct {
		Arg0 string `json:"id"`
	}{id}
	out := struct {
		Ret0 *TeacherWithRoster `json:"teacherWithRoster"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[2], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *userServiceClient) GetStudent(ctx context.Context, id string) (*StudentWithUser, error) {
	in := struct {
		Arg0 string `json:"id"`
	}{id}
	out := struct {
		Ret0 *StudentWithUser `json:"student"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[3], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *userServiceClient) GetStudentDetails(ctx context.Context, id string) (*StudentDetails, error) {
	in := struct {
		Arg0 string `json:"id"`
	}{id}
	out := struct {
		Ret0 *StudentDetails `json:"details"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[4], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

// HTTPClient is the interface used by generated clients to send HTTP requests.
// It is fulfilled by *(net/http).Client, which is sufficient for most users.
// Users can provide their own implementation for special retry policies.
type HTTPClient interface {
	Do(req *http.Request) (*http.Response, error)
}

// urlBase helps ensure that addr specifies a scheme. If it is unparsable
// as a URL, it returns addr unchanged.
func urlBase(addr string) string {
	// If the addr specifies a scheme, use it. If not, default to
	// http. If url.Parse fails on it, return it unchanged.
	url, err := url.Parse(addr)
	if err != nil {
		return addr
	}
	if url.Scheme == "" {
		url.Scheme = "http"
	}
	return url.String()
}

// newRequest makes an http.Request from a client, adding common headers.
func newRequest(ctx context.Context, url string, reqBody io.Reader, contentType string) (*http.Request, error) {
	req, err := http.NewRequestWithContext(ctx, "POST", url, reqBody)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", contentType)
	req.Header.Set("Content-Type", contentType)
	if headers, ok := HTTPRequestHeaders(ctx); ok {
		for k := range headers {
			for _, v := range headers[k] {
				req.Header.Add(k, v)
			}
		}
	}
	return req, nil
}

// doHTTPRequest is common code to make a request to the remote service.
func doHTTPRequest(ctx context.Context, client HTTPClient, url string, in, out interface{}) (*http.Response, error) {
	reqBody, err := json.Marshal(in)
	if err != nil {
		return nil, ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to marshal JSON body: %w", err))
	}
	if err = ctx.Err(); err != nil {
		return nil, ErrWebrpcRequestFailed.WithCause(fmt.Errorf("aborted because context was done: %w", err))
	}

	req, err := newRequest(ctx, url, bytes.NewBuffer(reqBody), "application/json")
	if err != nil {
		return nil, ErrWebrpcRequestFailed.WithCause(fmt.Errorf("could not build request: %w", err))
	}

	resp, err := client.Do(req)
	if err != nil {
		return nil, ErrWebrpcRequestFailed.WithCause(err)
	}

	if resp.StatusCode != 200 {
		respBody, err := io.ReadAll(resp.Body)
		if err != nil {
			return nil, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to read server error response body: %w", err))
		}

		var rpcErr WebRPCError
		if err := json.Unmarshal(respBody, &rpcErr); err != nil {
			return nil, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to unmarshal server error: %w", err))
		}
		if rpcErr.Cause != "" {
			rpcErr.cause = errors.New(rpcErr.Cause)
		}
		return nil, rpcErr
	}

	if out != nil {
		respBody, err := io.ReadAll(resp.Body)
		if err != nil {
			return nil, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to read response body: %w", err))
		}

		err = json.Unmarshal(respBody, &out)
		if err != nil {
			return nil, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to unmarshal JSON response body: %w", err))
		}
	}

	return resp, nil
}

func WithHTTPRequestHeaders(ctx context.Context, h http.Header) (context.Context, error) {
	if _, ok := h["Accept"]; ok {
		return nil, errors.New("provided header cannot set Accept")
	}
	if _, ok := h["Content-Type"]; ok {
		return nil, errors.New("provided header cannot set Content-Type")
	}

	copied := make(http.Header, len(h))
	for k, vv := range h {
		if vv == nil {
			copied[k] = nil
			continue
		}
		copied[k] = make([]string, len(vv))
		copy(copied[k], vv)
	}

	return context.WithValue(ctx, HTTPClientRequestHeadersCtxKey, copied), nil
}

func HTTPRequestHeaders(ctx context.Context) (http.Header, bool) {
	h, ok := ctx.Value(HTTPClientRequestHeadersCtxKey).(http.Header)
	return h, ok
}

//
// Helpers
//

type contextKey struct {
	name string
}

func (k *contextKey) String() string {
	return "webrpc context value " + k.name
}

var (
	HTTPClientRequestHeadersCtxKey = &contextKey{"HTTPClientRequestHeaders"}
	HTTPResponseWriterCtxKey       = &contextKey{"HTTPResponseWriter"}

	HTTPRequestCtxKey = &contextKey{"HTTPRequest"}

	ServiceNameCtxKey = &contextKey{"ServiceName"}

	MethodNameCtxKey = &contextKey{"MethodName"}
)

func ServiceNameFromContext(ctx context.Context) string {
	service, _ := ctx.Value(ServiceNameCtxKey).(string)
	return service
}

func MethodNameFromContext(ctx context.Context) string {
	method, _ := ctx.Value(MethodNameCtxKey).(string)
	return method
}

func RequestFromContext(ctx context.Context) *http.Request {
	r, _ := ctx.Value(HTTPRequestCtxKey).(*http.Request)
	return r
}
func ResponseWriterFromContext(ctx context.Context) http.ResponseWriter {
	w, _ := ctx.Value(HTTPResponseWriterCtxKey).(http.ResponseWriter)
	return w
}

//
// Errors
//

type WebRPCError struct {
	Name       string `json:"error"`
	Code       int    `json:"code"`
	Message    string `json:"msg"`
	Cause      string `json:"cause,omitempty"`
	HTTPStatus int    `json:"status"`
	cause      error
}

var _ error = WebRPCError{}

func (e WebRPCError) Error() string {
	if e.cause != nil {
		return fmt.Sprintf("%s %d: %s: %v", e.Name, e.Code, e.Message, e.cause)
	}
	return fmt.Sprintf("%s %d: %s", e.Name, e.Code, e.Message)
}

func (e WebRPCError) Is(target error) bool {
	if target == nil {
		return false
	}
	if rpcErr, ok := target.(WebRPCError); ok {
		return rpcErr.Code == e.Code
	}
	return errors.Is(e.cause, target)
}

func (e WebRPCError) Unwrap() error {
	return e.cause
}

func (e WebRPCError) WithCause(cause error) WebRPCError {
	err := e
	err.cause = cause
	err.Cause = cause.Error()
	return err
}

func (e WebRPCError) WithCausef(format string, args ...interface{}) WebRPCError {
	cause := fmt.Errorf(format, args...)
	err := e
	err.cause = cause
	err.Cause = cause.Error()
	return err
}

// Deprecated: Use .WithCause() method on WebRPCError.
func ErrorWithCause(rpcErr WebRPCError, cause error) WebRPCError {
	return rpcErr.WithCause(cause)
}

// Webrpc errors
var (
	ErrWebrpcEndpoint           = WebRPCError{Code: 0, Name: "WebrpcEndpoint", Message: "endpoint error", HTTPStatus: 400}
	ErrWebrpcRequestFailed      = WebRPCError{Code: -1, Name: "WebrpcRequestFailed", Message: "request failed", HTTPStatus: 400}
	ErrWebrpcBadRoute           = WebRPCError{Code: -2, Name: "WebrpcBadRoute", Message: "bad route", HTTPStatus: 404}
	ErrWebrpcBadMethod          = WebRPCError{Code: -3, Name: "WebrpcBadMethod", Message: "bad method", HTTPStatus: 405}
	ErrWebrpcBadRequest         = WebRPCError{Code: -4, Name: "WebrpcBadRequest", Message: "bad request", HTTPStatus: 400}
	ErrWebrpcBadResponse        = WebRPCError{Code: -5, Name: "WebrpcBadResponse", Message: "bad response", HTTPStatus: 500}
	ErrWebrpcServerPanic        = WebRPCError{Code: -6, Name: "WebrpcServerPanic", Message: "server panic", HTTPStatus: 500}
	ErrWebrpcInternalError      = WebRPCError{Code: -7, Name: "WebrpcInternalError", Message: "internal error", HTTPStatus: 500}
	ErrWebrpcClientDisconnected = WebRPCError{Code: -8, Name: "WebrpcClientDisconnected", Message: "client disconnected", HTTPStatus: 400}
	ErrWebrpcStreamLost         = WebRPCError{Code: -9, Name: "WebrpcStreamLost", Message: "stream lost", HTTPStatus: 400}
	ErrWebrpcStreamFinished     = WebRPCError{Code: -10, Name: "WebrpcStreamFinished", Message: "stream finished", HTTPStatus: 200}
)

// Schema errors
var (
	ErrNoRequestForUError = WebRPCError{Code: 1000, Name: "NoRequestForUError", Message: "You already Made a request for that day ð\u009f¤¡", HTTPStatus: 420}
)
