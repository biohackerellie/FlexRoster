// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: requests.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const aLlRequests = `-- name: ALlRequests :many
SELECT id, "studentId", "studentName", "newTeacher", "newTeacherName", "currentTeacher", "currentTeacherName", "dateRequested", status, arrived, timestamp FROM "requests"
`

func (q *Queries) ALlRequests(ctx context.Context) ([]Request, error) {
	rows, err := q.db.Query(ctx, aLlRequests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Request
	for rows.Next() {
		var i Request
		if err := rows.Scan(
			&i.ID,
			&i.StudentId,
			&i.StudentName,
			&i.NewTeacher,
			&i.NewTeacherName,
			&i.CurrentTeacher,
			&i.CurrentTeacherName,
			&i.DateRequested,
			&i.Status,
			&i.Arrived,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const allStudentRequests = `-- name: AllStudentRequests :many
SELECT id, "studentId", "studentName", "newTeacher", "newTeacherName", "currentTeacher", "currentTeacherName", "dateRequested", status, arrived, timestamp FROM "requests"
WHERE "studentId" = $1
ORDER BY "dateRequested" DESC
`

func (q *Queries) AllStudentRequests(ctx context.Context, studentid string) ([]Request, error) {
	rows, err := q.db.Query(ctx, allStudentRequests, studentid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Request
	for rows.Next() {
		var i Request
		if err := rows.Scan(
			&i.ID,
			&i.StudentId,
			&i.StudentName,
			&i.NewTeacher,
			&i.NewTeacherName,
			&i.CurrentTeacher,
			&i.CurrentTeacherName,
			&i.DateRequested,
			&i.Status,
			&i.Arrived,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const newRequest = `-- name: NewRequest :exec
INSERT INTO "requests" (
  "status",
  "studentName",
  "studentId",
  "dateRequested",
  "currentTeacher",
  "currentTeacherName",
  "newTeacher",
  "newTeacherName",
  "arrived",
  "timestamp",
  "id"
)
VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  current_timestamp,
  floor(rand()*(80+1))
)
`

type NewRequestParams struct {
	Status             RequestStatus
	StudentName        string
	StudentId          string
	DateRequested      pgtype.Date
	CurrentTeacher     string
	CurrentTeacherName string
	NewTeacher         string
	NewTeacherName     string
	Arrived            pgtype.Bool
}

func (q *Queries) NewRequest(ctx context.Context, arg NewRequestParams) error {
	_, err := q.db.Exec(ctx, newRequest,
		arg.Status,
		arg.StudentName,
		arg.StudentId,
		arg.DateRequested,
		arg.CurrentTeacher,
		arg.CurrentTeacherName,
		arg.NewTeacher,
		arg.NewTeacherName,
		arg.Arrived,
	)
	return err
}

const studentRequestsQuery = `-- name: StudentRequestsQuery :many
SELECT requests.id, requests."studentId", requests."studentName", requests."newTeacher", requests."newTeacherName", requests."currentTeacher", requests."currentTeacherName", requests."dateRequested", requests.status, requests.arrived, requests.timestamp FROM "requests"
JOIN "user" ON "requests"."studentId" = "user"."id"
JOIN "students" ON "user"."email" = "students"."studentEmail"
JOIN "classrooms" ON "requests.newTeacher" = "classrooms"."teacherId"
WHERE "requests"."dateRequested" >= CURRENT_DATE
`

type StudentRequestsQueryRow struct {
	Request Request
}

func (q *Queries) StudentRequestsQuery(ctx context.Context) ([]StudentRequestsQueryRow, error) {
	rows, err := q.db.Query(ctx, studentRequestsQuery)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StudentRequestsQueryRow
	for rows.Next() {
		var i StudentRequestsQueryRow
		if err := rows.Scan(
			&i.Request.ID,
			&i.Request.StudentId,
			&i.Request.StudentName,
			&i.Request.NewTeacher,
			&i.Request.NewTeacherName,
			&i.Request.CurrentTeacher,
			&i.Request.CurrentTeacherName,
			&i.Request.DateRequested,
			&i.Request.Status,
			&i.Request.Arrived,
			&i.Request.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRequest = `-- name: UpdateRequest :exec
UPDATE "requests"
SET "status" = $2
WHERE "id" = $1
`

type UpdateRequestParams struct {
	ID     int32
	Status RequestStatus
}

func (q *Queries) UpdateRequest(ctx context.Context, arg UpdateRequestParams) error {
	_, err := q.db.Exec(ctx, updateRequest, arg.ID, arg.Status)
	return err
}

const userRequestQuery = `-- name: UserRequestQuery :many
SELECT requests.id, requests."studentId", requests."studentName", requests."newTeacher", requests."newTeacherName", requests."currentTeacher", requests."currentTeacherName", requests."dateRequested", requests.status, requests.arrived, requests.timestamp FROM "requests"
WHERE "studentId" = $1 OR "teacherId" = $1 OR "currentTeacher" = $1
`

type UserRequestQueryRow struct {
	Request Request
}

func (q *Queries) UserRequestQuery(ctx context.Context, studentid string) ([]UserRequestQueryRow, error) {
	rows, err := q.db.Query(ctx, userRequestQuery, studentid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserRequestQueryRow
	for rows.Next() {
		var i UserRequestQueryRow
		if err := rows.Scan(
			&i.Request.ID,
			&i.Request.StudentId,
			&i.Request.StudentName,
			&i.Request.NewTeacher,
			&i.Request.NewTeacherName,
			&i.Request.CurrentTeacher,
			&i.Request.CurrentTeacherName,
			&i.Request.DateRequested,
			&i.Request.Status,
			&i.Request.Arrived,
			&i.Request.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
