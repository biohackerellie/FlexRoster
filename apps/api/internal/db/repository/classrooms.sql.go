// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: classrooms.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const availabilityQuery = `-- name: AvailabilityQuery :many
SELECT id, "classroomId", date, available, "teacherId" FROM "availability"
`

func (q *Queries) AvailabilityQuery(ctx context.Context) ([]Availability, error) {
	rows, err := q.db.Query(ctx, availabilityQuery)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Availability
	for rows.Next() {
		var i Availability
		if err := rows.Scan(
			&i.ID,
			&i.ClassroomId,
			&i.Date,
			&i.Available,
			&i.TeacherId,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const classroomQuery = `-- name: ClassroomQuery :many
SELECT 
    "classrooms"."id", 
    "roomNumber", 
    "teacherName", 
    "classrooms"."teacherId", 
    "availability"."available", 
    "comment"
FROM 
    "classrooms"
LEFT JOIN 
    "availability" 
ON 
    "classrooms"."id" = "availability"."classroomId" 
    AND "availability"."date" >= CURRENT_DATE
`

type ClassroomQueryRow struct {
	ID          string
	RoomNumber  string
	TeacherName string
	TeacherId   pgtype.Text
	Available   pgtype.Bool
	Comment     pgtype.Text
}

func (q *Queries) ClassroomQuery(ctx context.Context) ([]ClassroomQueryRow, error) {
	rows, err := q.db.Query(ctx, classroomQuery)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ClassroomQueryRow
	for rows.Next() {
		var i ClassroomQueryRow
		if err := rows.Scan(
			&i.ID,
			&i.RoomNumber,
			&i.TeacherName,
			&i.TeacherId,
			&i.Available,
			&i.Comment,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countRosterByClassroomId = `-- name: CountRosterByClassroomId :one
SELECT COUNT(*)
FROM "students"
WHERE "classroomId" = $1
`

func (q *Queries) CountRosterByClassroomId(ctx context.Context, classroomid string) (int64, error) {
	row := q.db.QueryRow(ctx, countRosterByClassroomId, classroomid)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const teacherAvailableToday = `-- name: TeacherAvailableToday :one
SELECT "availability"."available"
FROM "availability"
WHERE "teacherId" = $1 AND "date" = CURRENT_DATE
`

func (q *Queries) TeacherAvailableToday(ctx context.Context, teacherid pgtype.Text) (bool, error) {
	row := q.db.QueryRow(ctx, teacherAvailableToday, teacherid)
	var available bool
	err := row.Scan(&available)
	return available, err
}

const todaysAvailability = `-- name: TodaysAvailability :many
SELECT "available", "id" 
FROM "availability"
WHERE "date" >= CURRENT_DATE
`

type TodaysAvailabilityRow struct {
	Available bool
	ID        string
}

func (q *Queries) TodaysAvailability(ctx context.Context) ([]TodaysAvailabilityRow, error) {
	rows, err := q.db.Query(ctx, todaysAvailability)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TodaysAvailabilityRow
	for rows.Next() {
		var i TodaysAvailabilityRow
		if err := rows.Scan(&i.Available, &i.ID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
