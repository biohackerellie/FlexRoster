// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: rosters.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const allStudentDetails = `-- name: AllStudentDetails :many
SELECT "studentEmail", "studentName", "classroomId", status, students.id, "user".id, name, email, "emailVerified", image, role, classrooms.id, "roomNumber", "teacherName", "teacherId", comment, "isFlex" FROM "students"
LEFT JOIN "user" ON "students"."studentEmail" = "user"."email"
LEFT JOIN "classrooms" ON "students"."classroomId" = "classrooms"."id"
WHERE "students"."id" = $1
`

type AllStudentDetailsRow struct {
	StudentEmail  string           `db:"studentEmail" json:"studentEmail"`
	StudentName   string           `db:"studentName" json:"studentName"`
	ClassroomId   string           `db:"classroomId" json:"classroomId"`
	Status        Status           `db:"status" json:"status"`
	ID            int32            `db:"id" json:"id"`
	ID_2          pgtype.Text      `db:"id_2" json:"id_2"`
	Name          pgtype.Text      `db:"name" json:"name"`
	Email         pgtype.Text      `db:"email" json:"email"`
	EmailVerified pgtype.Timestamp `db:"emailVerified" json:"emailVerified"`
	Image         pgtype.Text      `db:"image" json:"image"`
	Role          pgtype.Text      `db:"role" json:"role"`
	ID_3          pgtype.Text      `db:"id_3" json:"id_3"`
	RoomNumber    pgtype.Text      `db:"roomNumber" json:"roomNumber"`
	TeacherName   pgtype.Text      `db:"teacherName" json:"teacherName"`
	TeacherId     pgtype.Text      `db:"teacherId" json:"teacherId"`
	Comment       pgtype.Text      `db:"comment" json:"comment"`
	IsFlex        pgtype.Bool      `db:"isFlex" json:"isFlex"`
}

func (q *Queries) AllStudentDetails(ctx context.Context, id int32) ([]AllStudentDetailsRow, error) {
	rows, err := q.db.Query(ctx, allStudentDetails, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AllStudentDetailsRow
	for rows.Next() {
		var i AllStudentDetailsRow
		if err := rows.Scan(
			&i.StudentEmail,
			&i.StudentName,
			&i.ClassroomId,
			&i.Status,
			&i.ID,
			&i.ID_2,
			&i.Name,
			&i.Email,
			&i.EmailVerified,
			&i.Image,
			&i.Role,
			&i.ID_3,
			&i.RoomNumber,
			&i.TeacherName,
			&i.TeacherId,
			&i.Comment,
			&i.IsFlex,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const allStudentsMap = `-- name: AllStudentsMap :many
SELECT "students"."id", "students"."studentEmail", "students"."studentName", "students"."status", "classrooms"."teacherName"
FROM "students"
JOIN "classrooms" ON "students"."classroomId" = "classrooms"."id"
`

type AllStudentsMapRow struct {
	ID           int32  `db:"id" json:"id"`
	StudentEmail string `db:"studentEmail" json:"studentEmail"`
	StudentName  string `db:"studentName" json:"studentName"`
	Status       Status `db:"status" json:"status"`
	TeacherName  string `db:"teacherName" json:"teacherName"`
}

func (q *Queries) AllStudentsMap(ctx context.Context) ([]AllStudentsMapRow, error) {
	rows, err := q.db.Query(ctx, allStudentsMap)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AllStudentsMapRow
	for rows.Next() {
		var i AllStudentsMapRow
		if err := rows.Scan(
			&i.ID,
			&i.StudentEmail,
			&i.StudentName,
			&i.Status,
			&i.TeacherName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteStudent = `-- name: DeleteStudent :exec
DELETE FROM "students" WHERE "studentEmail" = $1
`

func (q *Queries) DeleteStudent(ctx context.Context, studentemail string) error {
	_, err := q.db.Exec(ctx, deleteStudent, studentemail)
	return err
}

type NewStudentParams struct {
	StudentEmail string `db:"studentEmail" json:"studentEmail"`
	StudentName  string `db:"studentName" json:"studentName"`
	Status       Status `db:"status" json:"status"`
	ClassroomId  string `db:"classroomId" json:"classroomId"`
}

const rosterByClassroomId = `-- name: RosterByClassroomId :many
SELECT
  s."id" AS "studentId",
  s."studentEmail" AS "studentEmail",
  c."id" AS "classroomId",
  c."roomNumber" AS "roomNumber",
  c."teacherName" AS "teacherName",
  c."teacherId" AS "teacherId",
  c."comment" AS "comment",
  COALESCE(a."available", FALSE) AS "available" 
FROM "students" s
JOIN "classrooms" c ON s."classroomId" = c."id"
LEFT JOIN "availability" a ON c."id" = a."classroomId" AND a."date" = CURRENT_DATE
WHERE s."classroomId" = $1
`

type RosterByClassroomIdRow struct {
	StudentId    int32       `db:"studentId" json:"studentId"`
	StudentEmail string      `db:"studentEmail" json:"studentEmail"`
	ClassroomId  string      `db:"classroomId" json:"classroomId"`
	RoomNumber   string      `db:"roomNumber" json:"roomNumber"`
	TeacherName  string      `db:"teacherName" json:"teacherName"`
	TeacherId    pgtype.Text `db:"teacherId" json:"teacherId"`
	Comment      pgtype.Text `db:"comment" json:"comment"`
	Available    bool        `db:"available" json:"available"`
}

func (q *Queries) RosterByClassroomId(ctx context.Context, classroomid string) ([]RosterByClassroomIdRow, error) {
	rows, err := q.db.Query(ctx, rosterByClassroomId, classroomid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RosterByClassroomIdRow
	for rows.Next() {
		var i RosterByClassroomIdRow
		if err := rows.Scan(
			&i.StudentId,
			&i.StudentEmail,
			&i.ClassroomId,
			&i.RoomNumber,
			&i.TeacherName,
			&i.TeacherId,
			&i.Comment,
			&i.Available,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rosterById = `-- name: RosterById :many
SELECT "studentEmail", "studentName", "classroomId", status, id FROM "students" WHERE "id" = $1
`

func (q *Queries) RosterById(ctx context.Context, id int32) ([]Student, error) {
	rows, err := q.db.Query(ctx, rosterById, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Student
	for rows.Next() {
		var i Student
		if err := rows.Scan(
			&i.StudentEmail,
			&i.StudentName,
			&i.ClassroomId,
			&i.Status,
			&i.ID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rosterByTeacherId = `-- name: RosterByTeacherId :many
SELECT "students"."studentEmail", "students"."studentName","students"."status", "user"."id" AS "studentId", "classrooms"."roomNumber", "classrooms"."teacherName", "classrooms"."id" AS "classroomId", "classrooms"."comment"
FROM "students"
JOIN "classrooms" ON "students"."classroomId" = "classrooms"."id"
LEFT JOIN "user" ON "students"."studentEmail" = "user"."email"
WHERE "classrooms"."teacherId" = $1
`

type RosterByTeacherIdRow struct {
	StudentEmail string      `db:"studentEmail" json:"studentEmail"`
	StudentName  string      `db:"studentName" json:"studentName"`
	Status       Status      `db:"status" json:"status"`
	StudentId    pgtype.Text `db:"studentId" json:"studentId"`
	RoomNumber   string      `db:"roomNumber" json:"roomNumber"`
	TeacherName  string      `db:"teacherName" json:"teacherName"`
	ClassroomId  string      `db:"classroomId" json:"classroomId"`
	Comment      pgtype.Text `db:"comment" json:"comment"`
}

func (q *Queries) RosterByTeacherId(ctx context.Context, teacherid pgtype.Text) ([]RosterByTeacherIdRow, error) {
	rows, err := q.db.Query(ctx, rosterByTeacherId, teacherid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RosterByTeacherIdRow
	for rows.Next() {
		var i RosterByTeacherIdRow
		if err := rows.Scan(
			&i.StudentEmail,
			&i.StudentName,
			&i.Status,
			&i.StudentId,
			&i.RoomNumber,
			&i.TeacherName,
			&i.ClassroomId,
			&i.Comment,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rosterQuery = `-- name: RosterQuery :many
SELECT "studentEmail", "studentName", "classroomId", status, id FROM "students"
`

func (q *Queries) RosterQuery(ctx context.Context) ([]Student, error) {
	rows, err := q.db.Query(ctx, rosterQuery)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Student
	for rows.Next() {
		var i Student
		if err := rows.Scan(
			&i.StudentEmail,
			&i.StudentName,
			&i.ClassroomId,
			&i.Status,
			&i.ID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRoster = `-- name: UpdateRoster :exec
UPDATE "students"
SET "classroomId" = $1, "status" = $2
WHERE "studentEmail" = $3
`

type UpdateRosterParams struct {
	ClassroomId  string `db:"classroomId" json:"classroomId"`
	Status       Status `db:"status" json:"status"`
	StudentEmail string `db:"studentEmail" json:"studentEmail"`
}

func (q *Queries) UpdateRoster(ctx context.Context, arg UpdateRosterParams) error {
	_, err := q.db.Exec(ctx, updateRoster, arg.ClassroomId, arg.Status, arg.StudentEmail)
	return err
}

const updateStudentStatus = `-- name: UpdateStudentStatus :exec
UPDATE "students"
SET "status" = $1
WHERE "studentEmail" = $2
`

type UpdateStudentStatusParams struct {
	Status       Status `db:"status" json:"status"`
	StudentEmail string `db:"studentEmail" json:"studentEmail"`
}

func (q *Queries) UpdateStudentStatus(ctx context.Context, arg UpdateStudentStatusParams) error {
	_, err := q.db.Exec(ctx, updateStudentStatus, arg.Status, arg.StudentEmail)
	return err
}
